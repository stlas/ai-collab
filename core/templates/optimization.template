Optimiere folgenden Code fÃ¼r maximale Performance und Effizienz: ${PROMPT}

## âš¡ Performance-Optimierungs-Framework:

### 1. Profiling & Messung
- **Baseline:** Aktuelle Performance-Metriken
- **Bottlenecks:** Identifikation der langsamsten Teile
- **Resource Usage:** CPU, Memory, I/O, Network

### 2. Algorithmus-Optimierung
- **KomplexitÃ¤ts-Analyse:** Big O Notation Review
- **Datenstrukturen:** Optimale Container-Wahl
- **Algorithmus-Alternativen:** Effizientere LÃ¶sungsansÃ¤tze

### 3. Code-Level-Optimierungen
```
// Vorher (unoptimiert):
[Originaler Code]
// Performance: [Metriken]

// Nachher (optimiert):
[Optimierter Code]
// Performance: [Verbesserte Metriken]
// Verbesserung: [X% schneller, Y% weniger Memory]
```

### 4. Speicher-Optimierung
- **Memory Pools:** Wiederverwendung von Objekten
- **Garbage Collection:** Minimierung der GC-Pressure
- **Memory Leaks:** Vermeidung von Speicherlecks

### 5. I/O-Optimierung
- **Batch Operations:** Reduzierung von I/O-Calls
- **Asynchrone Verarbeitung:** Non-blocking Operations
- **Caching:** Intelligentes Zwischenspeichern

### 6. Concurrency & ParallelitÃ¤t
- **Thread Safety:** Sichere Parallelverarbeitung
- **Load Balancing:** GleichmÃ¤ÃŸige Arbeitsverteilung
- **Lock-Free Algorithms:** Vermeidung von Sperren

## ğŸ¯ Optimierungs-Strategien:

### ğŸ”„ Lazy Loading
- On-demand Initialisierung
- VerzÃ¶gerte Ressourcen-Allokation

### ğŸ“Š Data Structures
- Optimale Container-Wahl
- Index-Strategien
- Hashing-Optimierung

### ğŸ§  Algorithmic Improvements
- Memoization
- Dynamic Programming
- Divide & Conquer

### ğŸ’¾ Resource Management
- Connection Pooling
- Object Reuse
- Stream Processing

## ğŸ“ˆ Messbare Verbesserungen:

### Performance Metrics
- **Execution Time:** [Vorher] â†’ [Nachher] ([X%] Verbesserung)
- **Memory Usage:** [Vorher] â†’ [Nachher] ([Y%] Reduzierung)
- **Throughput:** [Vorher] â†’ [Nachher] ([Z%] Steigerung)

### Skalierbarkeit
- **Load Testing:** Verhalten unter Last
- **Stress Testing:** Breaking Points
- **Capacity Planning:** Wachstums-Projektionen

## âš–ï¸ Trade-off-Analyse:
- **Code-KomplexitÃ¤t vs. Performance**
- **Memory vs. Speed**
- **Maintainability vs. Optimization**

Liefere messbar verbesserten Code mit detaillierter Performance-Analyse und Benchmarks.